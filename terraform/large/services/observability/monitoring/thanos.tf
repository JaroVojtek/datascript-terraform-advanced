module "thanos-shared-ec1" {
  source = "github.com/lablabs/terraform-aws-eks-thanos.git?ref=v1.0.0"

  cluster_identity_oidc_issuer     = data.terraform_remote_state.shared-ec1.outputs.eks_cluster.eks.eks_cluster_identity_oidc_issuer
  cluster_identity_oidc_issuer_arn = data.terraform_remote_state.shared-ec1.outputs.eks_cluster.eks.eks_cluster_identity_oidc_issuer_arn

  helm_chart_version = "12.6.2"
  helm_release_name  = local.thanos_release_name

  namespace             = "monitoring"
  irsa_role_name_prefix = module.label-shared-ec1.id

  argo_enabled = true
  argo_sync_policy = {
    "automated" : {}
    "syncOptions" = ["CreateNamespace=true"]
  }

  thanos_query_enabled                         = true
  thanos_query_irsa_additional_policies        = local.thanos_common_additional_policies
  thanos_queryfrontend_enabled                 = true
  thanos_bucketweb_enabled                     = true
  thanos_bucketweb_irsa_additional_policies    = local.thanos_common_additional_policies
  thanos_compactor_enabled                     = true
  thanos_compactor_irsa_additional_policies    = local.thanos_common_additional_policies
  thanos_storegateway_enabled                  = true
  thanos_storegateway_irsa_additional_policies = local.thanos_common_additional_policies

  argo_kubernetes_manifest_field_manager_force_conflicts = true

  values = yamlencode({
    global : {
      storageClass : "ebs-csi-gp3"
    }
    commonLabels : local.thanos_common_labels
    query : {
      enabled : true
      replicaCount : 2
      podLabels : local.thanos_common_labels
      podAnnotations : {
        "cluster-autoscaler.kubernetes.io/safe-to-evict" : "true"
      }
      priorityClassName : local.thanos_common_priority_class_name
      pdb : {
        create : true
        minAvailable : 1
      }
      affinity = { # affinity cannot be unset, so we need to use it instead of topologySpreadConstraints
        podAntiAffinity = {
          preferredDuringSchedulingIgnoredDuringExecution = [{
            weight = 100
            podAffinityTerm = {
              labelSelector = {
                matchLabels = {
                  "app.kubernetes.io/name"      = "thanos"
                  "app.kubernetes.io/instance"  = local.thanos_release_name
                  "app.kubernetes.io/component" = "query"
                }
              }
              topologyKey = "topology.kubernetes.io/zone"
            }
          }]
          requiredDuringSchedulingIgnoredDuringExecution = [{
            labelSelector = {
              matchLabels = {
                "app.kubernetes.io/name"      = "thanos"
                "app.kubernetes.io/instance"  = local.thanos_release_name
                "app.kubernetes.io/component" = "query"
              }
            }
            topologyKey = "kubernetes.io/hostname"
          }]
        }
      }
      nodeSelector : local.thanos_common_node_selector
      tolerations : local.thanos_common_tolerations
      dnsDiscovery : {
        enabled : false
      }
      grpc : {
        client : {
          tls : {
            enabled : true
            autoGenerated : true
          }
        }
      }
      stores : concat(
        [
          "thanos-store.shared-ec1.${local.root_dns_domain}:443",
          "${module.prometheus-shared-ec1.prometheus_thanos_sidecar_hostname}:443",
        ],
        local.prometheus_thanos_sidecar_hostnames
      )
      extraFlags : [
        "--query.auto-downsampling",
        "--query.partial-response",
        "--query.max-concurrent=50"
      ]
      resources : {
        requests : {
          cpu : "250m"
          memory : "1000Mi"
        }
      }
      replicaLabel : ["prometheus_replica"]
    }
    queryFrontend : {
      enabled : true
      replicaCount : 2
      podLabels : local.thanos_common_labels
      podAnnotations : {
        "cluster-autoscaler.kubernetes.io/safe-to-evict" : "true"
      }
      priorityClassName : local.thanos_common_priority_class_name
      pdb : {
        create : true
        minAvailable : 1
      }
      affinity = { # affinity cannot be unset, so we need to use it instead of topologySpreadConstraints
        podAntiAffinity = {
          preferredDuringSchedulingIgnoredDuringExecution = [{
            weight = 100
            podAffinityTerm = {
              labelSelector = {
                matchLabels = {
                  "app.kubernetes.io/name"      = "thanos"
                  "app.kubernetes.io/instance"  = local.thanos_release_name
                  "app.kubernetes.io/component" = "query-frontend"
                }
              }
              topologyKey = "topology.kubernetes.io/zone"
            }
          }]
          requiredDuringSchedulingIgnoredDuringExecution = [{
            labelSelector = {
              matchLabels = {
                "app.kubernetes.io/name"      = "thanos"
                "app.kubernetes.io/instance"  = local.thanos_release_name
                "app.kubernetes.io/component" = "query-frontend"
              }
            }
            topologyKey = "kubernetes.io/hostname"
          }]
        }
      }
      nodeSelector : local.thanos_common_node_selector
      tolerations : local.thanos_common_tolerations
      resources : {
        requests : {
          cpu : "250m"
          memory : "1000Mi"
        }
      }
      config : {
        type : "IN-MEMORY"
        config : {
          max_size : "1GB"
        }
      }
      extraFlags : [
        "--query-frontend.log-queries-longer-than=30s",
        "--query-frontend.compress-responses",
        "--query-range.partial-response",
        "--query-range.request-downsampled"
      ]
      ingress : {
        enabled : true
        ingressClassName : "nginx-internal"
        annotations : {
          "nginx.ingress.kubernetes.io/ssl-redirect" : "true"
          "nginx.ingress.kubernetes.io/force-ssl-redirect" : "true"
          "cert-manager.io/cluster-issuer" : "default"
        }
        hostname : "thanos.shared-ec1.${local.root_dns_domain}"
        path : "/"
        tls : true
      }
    }
    storegateway : {
      enabled : true
      replicaCount : 2
      podLabels : local.thanos_common_labels
      podAnnotations : {
        "cluster-autoscaler.kubernetes.io/safe-to-evict" : "true"
      }
      priorityClassName : local.thanos_common_priority_class_name
      pdb : {
        create : true
        minAvailable : 1
      }
      affinity = { # affinity cannot be unset, so we need to use it instead of topologySpreadConstraints
        podAntiAffinity = {
          preferredDuringSchedulingIgnoredDuringExecution = [{
            weight = 100
            podAffinityTerm = {
              labelSelector = {
                matchLabels = {
                  "app.kubernetes.io/name"      = "thanos"
                  "app.kubernetes.io/instance"  = local.thanos_release_name
                  "app.kubernetes.io/component" = "storegateway"
                }
              }
              topologyKey = "topology.kubernetes.io/zone"
            }
          }]
          requiredDuringSchedulingIgnoredDuringExecution = [{
            labelSelector = {
              matchLabels = {
                "app.kubernetes.io/name"      = "thanos"
                "app.kubernetes.io/instance"  = local.thanos_release_name
                "app.kubernetes.io/component" = "storegateway"
              }
            }
            topologyKey = "kubernetes.io/hostname"
          }]
        }
      }
      nodeSelector : local.thanos_common_node_selector
      tolerations : local.thanos_common_tolerations
      resources : {
        requests : {
          cpu : "500m"
          memory : "3000Mi"
        }
      }
      persistence : {
        enabled : true
        size : "100Gi"
      }
      extraFlags : [
        "--store.grpc.series-max-concurrency=50",
      ]
      ingress : {
        grpc : {
          enabled : true
          ingressClassName : "nginx-internal"
          annotations : {
            "nginx.ingress.kubernetes.io/ssl-redirect" : "true"
            "nginx.ingress.kubernetes.io/backend-protocol" : "GRPC"
            "nginx.ingress.kubernetes.io/proxy-read-timeout" : "160"
            "cert-manager.io/cluster-issuer" : "default"
          }
          hostname : "thanos-store.shared-ec1.${local.root_dns_domain}"
          tls : true
        }
      }
    }
    compactor : {
      enabled : true
      replicaCount : 1
      podLabels : local.thanos_common_labels
      podAnnotations : {
        "cluster-autoscaler.kubernetes.io/safe-to-evict" : "true"
      }
      priorityClassName : local.thanos_common_priority_class_name
      affinity = { # affinity cannot be unset, so we need to use it instead of topologySpreadConstraints
        podAntiAffinity = {
          preferredDuringSchedulingIgnoredDuringExecution = [{
            weight = 100
            podAffinityTerm = {
              labelSelector = {
                matchLabels = {
                  "app.kubernetes.io/name"      = "thanos"
                  "app.kubernetes.io/instance"  = local.thanos_release_name
                  "app.kubernetes.io/component" = "compactor"
                }
              }
              topologyKey = "topology.kubernetes.io/zone"
            }
          }]
          requiredDuringSchedulingIgnoredDuringExecution = [{
            labelSelector = {
              matchLabels = {
                "app.kubernetes.io/name"      = "thanos"
                "app.kubernetes.io/instance"  = local.thanos_release_name
                "app.kubernetes.io/component" = "compactor"
              }
            }
            topologyKey = "kubernetes.io/hostname"
          }]
        }
      }
      nodeSelector : local.thanos_common_node_selector
      tolerations : local.thanos_common_tolerations
      resources : {
        requests : {
          cpu : "1000m"
          memory : "1000Mi"
        }
      }
      persistence : {
        enabled : true
        size : "100Gi"
      }
      ingress : {
        enabled : true
        ingressClassName : "nginx-internal"
        annotations : {
          "nginx.ingress.kubernetes.io/ssl-redirect" : "true"
          "nginx.ingress.kubernetes.io/force-ssl-redirect" : "true"
          "cert-manager.io/cluster-issuer" : "default"
        }
        hostname : "thanos-compactor.shared-ec1.${local.root_dns_domain}"
        path : "/"
        tls : true
      }
    }
    bucketweb : {
      enabled : true
      replicaCount : 2
      podLabels : local.thanos_common_labels
      podAnnotations : {
        "cluster-autoscaler.kubernetes.io/safe-to-evict" : "true"
      }
      pdb : {
        create : true
        minAvailable : 1
      }
      affinity = { # affinity cannot be unset, so we need to use it instead of topologySpreadConstraints
        podAntiAffinity = {
          preferredDuringSchedulingIgnoredDuringExecution = [{
            weight = 100
            podAffinityTerm = {
              labelSelector = {
                matchLabels = {
                  "app.kubernetes.io/name"      = "thanos"
                  "app.kubernetes.io/instance"  = local.thanos_release_name
                  "app.kubernetes.io/component" = "bucketweb"
                }
              }
              topologyKey = "topology.kubernetes.io/zone"
            }
          }]
          requiredDuringSchedulingIgnoredDuringExecution = [{
            labelSelector = {
              matchLabels = {
                "app.kubernetes.io/name"      = "thanos"
                "app.kubernetes.io/instance"  = local.thanos_release_name
                "app.kubernetes.io/component" = "bucketweb"
              }
            }
            topologyKey = "kubernetes.io/hostname"
          }]
        }
      }
      nodeSelector : local.thanos_common_node_selector
      tolerations : local.thanos_common_tolerations
      resources : {
        requests : {
          cpu : "200m"
          memory : "250Mi"
        }
      }
      ingress : {
        enabled : true
        ingressClassName : "nginx-internal"
        annotations : {
          "nginx.ingress.kubernetes.io/ssl-redirect" : "true"
          "nginx.ingress.kubernetes.io/force-ssl-redirect" : "true"
          "cert-manager.io/cluster-issuer" : "default"
        }
        hostname : "thanos-bucketweb.shared-ec1.${local.root_dns_domain}"
        path : "/"
        tls : true
      }
    }
    objstoreConfig : {
      type : "S3",
      config : {
        bucket : module.thanos-shared-ec1-bucket.bucket_id,
        region : module.thanos-shared-ec1-bucket.bucket_region,
        endpoint : "s3.${module.thanos-shared-ec1-bucket.bucket_region}.amazonaws.com"
      }
    }
    metrics : {
      enabled : true
      serviceMonitor : {
        enabled : true
      }
    }
  })

  providers = {
    aws        = aws.shared-ec1
    kubernetes = kubernetes.shared-ec1
  }
}
